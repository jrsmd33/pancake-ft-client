<!DOCTYPE html>
<html>
<head>
  <title>Pancake: Tester</title>
</head>
<body>
  <div id="container">
    <header data-bind="text: name"></header>
    <section>
      <p># ancestors: <span data-bind="text: ancestorsCount">-</span></p>
    </section>
  </div>

<script type="text/javascript">
  var config = {
    packages: {
      // package mappings
      'dollar': './vendor/zepto',
      'underscore': './vendor/underscore',
      'knockout': './vendor/knockout',
      'compose': './vendor/compose',
      'promise': './vendor/store/lib/Promise',
      'json': './lib/json',
      'text': 'vendor/plugin/text'
    },
    // UTC timestamp 
    pageLoadStartTime: Date.now()+(new Date().getTimezoneOffset()*60000)
  };
  // some browser shims
  config.platform = 'web';
  config.packages.logger = 'lib/logger.browser';
</script>

<script src="../js/vendor/requirejs.js?v={{v}}"></script>
<script>
  config.appName = "main";
  console.log("bootstrapping for platform: ", config.platform, config);
  require({
    // configure our AMD loader
    baseUrl: '../js',
    paths: config.packages,
    waitSeconds: 20,
    urlArgs: "r={{v}}" // r is a cache-busting token
  }, ['knockout', 'underscore'], function(ko, util){

    console.log("underscore: ", util);
    
    function isObservableArray(thing) {
      return (
        'function' === typeof thing.valueWillMutate &&
        'function' === typeof thing &&
        (thing() instanceof Array)
      );
    }

    ko.extenders.composeWith = function(target, functions) {
      // target is the original observable array
      console.log("reduceWith, got target: ", target());
      
      // create the observable we'll return and update with the result of the reduce
      var placeholder = ko.observable('');
      console.log("declared placeholder");
      
      // take a copy so we don't change the original ref, which might be reused elsewhere
      functions = functions.slice(0);
      // underscore's compose calls our functions in reverse order
      // me personally, I prefer a left-right chain so its like value = ar.map(fn).map(fn2).map(n3);
      functions.reverse(); 
      
      var composedHandler = util.compose.apply(util, functions);
      
      function onTargetChange(values){
        console.log("event on original observable target array, arguments are: ", values, " this: ", this);
        
        if(isObservableArray(values)) {
          console.log("observableArray subscriber was passed an observableArray");
          values = values();
        }

        console.log("are these values themselves observables? ", !!values.filter(ko.isObservable));
        if('function' !== typeof values.reduce){
          values = [values]
        }

        // unwrap each observable value
        var unwrapped = values.map(function(value){
          return ko.isObservable(value) ? ko.utils.unwrapObservable(value) : value;
        });
        console.log("unwrapped ", unwrapped);
        
        var results = composedHandler(unwrapped);
        placeholder(results);
        return results;
      }

      // get the initial values in the placeholder
      placeholder(onTargetChange( target ));
      // hook into future changes
      target.subscribe(onTargetChange);
      
      return placeholder;
    };

    var nameStream = window.nameStream = ko.observableArray([{ name: "Bob" }, { name: "Dave"}, { name: "Adam"}]);
    nameStream.subscribe(function(values){
      console.log("nameStream event: ", values );
    });
    
    var nameReducer = function(prev, val, idx){
      console.log("nameReducer: ", prev, val, idx);
      return prev + ", son of " + val;
    };
    
    function curryPlucker(key) {
      return function(values) {
        return values.map(function(value){ 
          return value[key]; 
        });
      }
    }

    function logger(name) {
      return function(values) {
        console.log(name + " logger: got values: ", values);
        return values;
      };
    }
    
    var viewModel = window.viewModel = {
      // open: open a stream (e.g. return observable which will be notified of events)
      // map: pass all values through this function - to returns replaced or transformed same number of values
      // filter: pass all values through this function - to return none or more values that evaluate to true by the filter fn
      
      name:  nameStream.extend({ 
        composeWith: [
          // logger('name field'), 
          curryPlucker('name'), 
          function(values) { 
            return values.reduce(nameReducer);
          },
          logger('post-name field') 
        ] 
      }),
      ancestorsCount: nameStream.extend({ 
        composeWith: [
          // logger('ancestorsCount field'), 
          util.tail, 
          util.size,
          logger('post-ancestorsCount field') 
        ]
      })
    };
    
    ko.applyBindings(viewModel, document.getElementById("container"));

  });
</script>

</body>
</html>
