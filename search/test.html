<!DOCTYPE html>
<html>
<head>
  <title>Pancake: Tester</title>
</head>
<body>
  <div id="container">
    <header></header>
    <section>
      <span data-bind="visible: !boards().length">No results</span>
      <ul data-bind="foreach: boards, visible: boards().length">
        <li data-bind="attr: { 'data-itemid': id }, click: $parent.onaction"><span data-bind="text: title"></span>  <span data-action="remove" class="remove">X</span></li>
      </ul>
    </section>
  </div>

<script src="../js/config.js"></script>
<script src="../js/vendor/requirejs.js?v={{v}}"></script>
<script>
  require({
    // configure our AMD loader
    baseUrl: '../js',
    packages: config.packages,
    paths: config.paths,
    waitSeconds: 20,
    urlArgs: "r={{v}}" // r is a cache-busting token
  }, ['knockout', 'EventEmitter', 'store', 'promise'], function(ko, EventEmitter, Store, Promise){

    store = Store.Observable(new Store.Memory({
      data: [
        { title: "Board one", type_board: true },
        { title: "Board two", type_board: true },
        { title: "Bob", type_board: false, type_user: true, expires: Date.now()+5000 }
      ].map(function(item){
        if(!item.id) item.id = Math.random();
        return item;
      })
      
    }));
    
    function createStream(options){
      var stream = new EventEmitter(); 
      console.log("Created stream with options: ", options);
      return stream;
    }
    service = {};
    service.boards = function(sink) {
      // getter
      var options = {};
      var stream = service.boards.stream || (this.stream = createStream(options));
      // attach one end to the provided sink
      stream.addListener('data', sink.ondata);
      // steam.on('pause', sink.onPause)
      // steam.on('reset', sink.onReset)
      
      // and attach the other to the source
      var results = store.query({ type_board: true });
      Promise.when(results, function(data){
          // Initial results came back for boards query
          stream.emitEvent('data', [data, null]);
      }, function(err){
        stream.emitEvent('error', [err]);
      });
      results.observe(function(data, fromIndex, toIndex){
        // update on type_board results
        stream.emitEvent('data', [data, {
          fromIndex: fromIndex, 
          toIndex: toIndex
        }]);
      }, true);
      return stream;
    };

    viewModel = {
      onaction: function(item, evt){
        var action = evt.originalTarget.getAttribute('data-action');
        var id = item.id;
        console.log("remove: ", action, id);
        store.remove(id);
      },
      boards: ko.observableArray().extend({ 
        wireTo: service.boards
      })
    };
    
    // var boardsSink = {
    //   ondata: function(data, details){
    //     // update viewmodel from data event
    //     if(this.paused) return;
    //     console.log("data event from boardsStream: ", data, details);
    //     // simplest case""
    //     viewModel.boards.removeAll();
    //     // one at a time: 
    //     // data.forEach(function(item){
    //     //   viewModel.boards.push(item);
    //     // });
    //     // or in batch:
    //     var spliceArgs = [0, 0].concat(data); 
    //     console.log("Calling splice with args: ", spliceArgs);
    //     viewModel.boards.splice.apply(viewModel.boards, spliceArgs);
    //   },
    //   pause: function(){
    //     this.paused = true;
    //   },
    //   resume: function(){
    //     this.paused = false;
    //   }
    // };
    // var boardsStream = service.boards(boardsSink);
    // 
    ko.applyBindings(viewModel);
  });
</script>

</body>
</html>
